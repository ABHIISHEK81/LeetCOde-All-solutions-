//  3459. Length of Longest V-Shaped Diagonal Segment  //






class Solution:
    def lenOfVDiagonal(self, grid):
        if not grid: 
            return 0
        n = len(grid)
        m = len(grid[0])
       
        dirs = [(1,1), (1,-1), (-1,-1), (-1,1)]
        next_dir = {0:1, 1:2, 2:3, 3:0}
        allowed = {(1,2), (2,0), (0,2)}

        forward_len = [[[0]*m for _ in range(n)] for _ in range(4)]
        dp_end_with1 = [[[0]*m for _ in range(n)] for _ in range(4)]

        for d, (dx, dy) in enumerate(dirs):
    
            for i in range(n):
                for j in range(m):
                    pi = i - dx
                    pj = j - dy
                    if 0 <= pi < n and 0 <= pj < m:
                        continue
                    seq = []
                    x, y = i, j
                    while 0 <= x < n and 0 <= y < m:
                        seq.append((x, y))
                        x += dx
                        y += dy

                    for idx, (x, y) in enumerate(seq):
                        val = 1 if grid[x][y] == 1 else 0
                        if idx > 0:
                            px, py = seq[idx-1]
                            if (grid[px][py], grid[x][y]) in allowed and dp_end_with1[d][px][py] > 0:
                                val = max(val, dp_end_with1[d][px][py] + 1)
                        dp_end_with1[d][x][y] = val

                    for idx in range(len(seq)-1, -1, -1):
                        x, y = seq[idx]
                        if idx == len(seq)-1:
                            forward_len[d][x][y] = 1
                        else:
                            nx, ny = seq[idx+1]
                            if (grid[x][y], grid[nx][ny]) in allowed:
                                forward_len[d][x][y] = forward_len[d][nx][ny] + 1
                            else:
                                forward_len[d][x][y] = 1

        ans = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    for d in range(4):
                        ans = max(ans, forward_len[d][i][j])
        for d in range(4):
            nd = next_dir[d]
            for i in range(n):
                for j in range(m):
                    if dp_end_with1[d][i][j] > 0 and forward_len[nd][i][j] > 0:
                        ans = max(ans, dp_end_with1[d][i][j] + forward_len[nd][i][j] - 1)

        return ans
